# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
import sys
import yaml
from pathlib import Path

import synthtool as s
from synthtool import log, shell, _tracked_paths
from synthtool.gcp.common import CommonTemplates
from synthtool.sources import templates

PB2_HEADER = r"""(\# -\*- coding: utf-8 -\*-\n)(\# Generated by the protocol buffer compiler\.  DO NOT EDIT!.*?# source: .*?\.proto)"""
PB2_GRPC_HEADER = r"""(\# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!)
(import grpc)"""

LICENSE = """
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License."""

SAMPLES_VERSIONS = ["2.7", "3.6", "3.7", "3.8"]
IGNORED_VERSIONS = ["2.7"]

def fix_pb2_headers(*, proto_root: str = "**/*_pb2.py") -> None:
    s.replace(
        proto_root,
        PB2_HEADER,
        fr"\g<1>{LICENSE}\n\n\g<2>",  # change order to avoid stacking replacements
        flags=re.DOTALL | re.MULTILINE,
    )


def fix_pb2_grpc_headers(*, proto_root: str = "**/*_pb2_grpc.py") -> None:
    s.replace(
        proto_root,
        PB2_GRPC_HEADER,
        fr"{LICENSE}\n\n\g<1>\n\n\g<2>",  # add line breaks to avoid stacking replacements
    )


def _get_help(filename: str) -> str:
    return shell.run(["python", filename, "--help"]).stdout


def _get_noxfile_metadata(noxfile: Path) -> dict:
    with open(noxfile) as f:
        metadata = yaml.load(f, Loader=yaml.SafeLoader) or {}

    # set defaults
    metadata["DEFAULT_VERSIONS"] = SAMPLES_VERSIONS
    if "ignored_versions" not in metadata:
        metadata["ignored_versions"] = IGNORED_VERSIONS
    if "install_library_from_source" not in metadata:
        metadata["install_library_from_source"] = False

    return metadata


def _get_sample_readme_metadata(sample_project_dir: Path) -> dict:
    # install packages required to run sample
    requirements = str(Path(sample_project_dir / "requirements.txt").resolve())
    sample_readme = sample_project_dir / "README.rst.in"
    log.debug(f"Installing requirements at {requirements} to generate {sample_readme}")
    shell.run([sys.executable, "-m", "pip", "install", "-r", requirements])

    with open(sample_readme) as f:
        sample_metadata = yaml.load(f, Loader=yaml.SafeLoader)
    for sample in sample_metadata["samples"]:
        # add absolute path so `python foo.py --help` succeeds
        sample["abs_path"] = Path(sample_project_dir / (sample["file"])).resolve()

    return sample_metadata


def py_samples(*, root=".") -> None:
    """
    Find all samples projects and render templates.
    Samples projects always have a noxfile.py.yml, and may optionally have a
    README.rst.in.
    """

    template_root = Path(CommonTemplates()._template_root)
    t = templates.TemplateGroup(template_root / "python_samples")

    # for legacy sample readmegen
    t.env.globals["get_help"] = _get_help

    excludes = ["**/*tmpl*"]  # Don't copy .tmpl. files
    for noxfile in Path(root).glob("**/noxfile.py.yml"):
        sample_project_dir = noxfile.parent
        log.info(f"Generating templates for samples project '{sample_project_dir}'")

        noxfile_metadata = _get_noxfile_metadata(noxfile)
        sample_readme = sample_project_dir / "README.rst.in"
        if sample_readme.exists():
            sample_metadata = _get_sample_readme_metadata(sample_project_dir)
        else:
            excludes.append("**/*README.rst")

        result = t.render(
            subdir=str(sample_project_dir), **noxfile_metadata, **sample_metadata
        )
        _tracked_paths.add(result)
        s.copy([result], excludes=excludes)  # don't copy partials files
